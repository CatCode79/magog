# vim:ts=2:sw=2:sts=2:tw=72:noet:ai:foldmethod=indent

* Stuff
	* TODO Edit and play
		Switch to game from an edited scenario, see how it plays out. Then
		rewind back to the editor with the changes that happend during
		gameplay rolled back.
	* TODO Command-line interface
		The ultimate tool for custom UI. Use an imgui idiom, have a text
		buffer widget that edits a mutable string while it's being polled
		and returns true when the user pressed enter.
	* TODO Stop batching everything in rendering
		Using the exact same shader program and vertex signature for
		everything that gets drawn is too limiting. For example, the font
		would be better drawn with an alpha blending shader rather than the
		sprite shader.
	* TODO Asynchronous animations framework
		Animations are fired off from events that take place during play,
		but they never block further game logic events from taking place, so
		having lots of animation going on won't slow down the turn-based
		gameplay. Some obviously useful effects: Floating text over a map
		cell. Particle cloud damage effect. Fading line on projectile
		trajectory. A puff of smoke when a mob is summoned.
	* TODO Test simple dynamic lighting
		Add light values and light sources to the area data. Have a zone of
		improved visibility around the player when it's dim. Have a cutoff
		into blinding total darkness in the visuals when there is absolutely
		no light.
	* TODO Sleep when out of focus
		The app constantly updates the screen, which eats a lot of processor
		power. The player should be able to switch to other applications and
		have full processing power available to them, so make the event
		system detect focus events and switch to sleep mode.

		Also possibly make the screen updates less intesive? Rule of thumb
		is that we don't do anything with screen refresh rates below 30 ms,
		since that's the key repeat rate you get when leaning on keys,
		there's no twitch gameplay, and the animations are very low-fi.
	* TODO Basic unintrusive audio support
		Something like a click sound for acknowlegdging input. Mostly to see
		how to get an audio mixer and a simple waveform synth set up.
	* FIXME GUI terrain tiles need to have higher Z layer than terrain
		Currently a GUI element floor terrain will get overwritten by actual
		map display block terrain. The fix will probably tie making the
		renderer non-batching. Then we can just use regular draw order
		tricks and wiping the depth buffer after map draw for the GUI stuff.
* Non-critical stuff
	These don't make new features.
	* TODO Complete set of terrain predicates in the terrain cell type
		Will still want to keep predicates that can depend on more than just
		the cell in a place that can access everything in the space. For
		example, mobs block paths, sometimes move so little you can count
		them as stable obstacles, and some might block FOV.
	* TODO Offline image processing
		Drop image and ttf loading from the end result binaries, make them
		smaller and faster to start up.

		Write an external utility that builds atlas textures from images and
		rasterized fonts and converts these into bitmap data. Compress
		texture data bytes with crate flate and bake into the binary as
		embedded data. Will also need to emit a metadata structure to list
		the sprite bounds. Static struct literals should work.

		Can add additional image processing steps instead of just turning
		the images as is into sprites as is done now. One example would be
		using a bright color as the transparent one for the sprites, which
		end up having #000000 as the transparent color as end result
		textures.
	* TODO Nicer Dijkstra map type
		- Make Dijkstra map a proper type.
		- Create a trait for the source type that provides the neighbors
		  function.
		- Give the Dijkstra map type a method "slope" for returning a vector
		  of the neighbors of a cell, sorted by their score. Downhill and
		  uphill values are now the first and last elements of this vector.
	* TODO Use include_bin!() to bake in binary assets
	* TODO Doc comments, document generation
